# MIT 6.828 实验笔记
***
## LAB1 
### PART1 : PC引导程序
* 本项目部分代码使用的是x86汇编，并使用QEMU/GDB调试，如何对汇编语言不太熟悉可以通过如下网址熟悉
>> https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf
##### 练习1：熟悉汇编语言

#### 模拟x86
* 使用QEMU来模拟真实的个人计算机来开发操作系统，并且通过GDB可以在x86内部设置断点。
* 首先构建项目
```C
cd lab
make
```
* 安装好QEMU后，我们可以开始使用QEMU来引导我么的内核啦！(如果你还没有安装好，可以参考如下网址）
>> https://pdos.csail.mit.edu/6.828/2018/tools.html
>> https://www.cnblogs.com/gatsby123/p/9746193.html
* 接下来进入内核
```
make qemu
```
* 在内核中可以使用两个命令
```C++
help        //显示此命令列表
kerninfo    //显示有关内核的信息
```
#### ROM BIOS
* 在lab目录下打开两个端口，分别运行make qemu-gdb 和 make gdb
* 该实验提供了一个.gdbinit文件，用于设置 GDB 以调试早期启动期间使用的 16 位代码，并指示它附加到侦听 QEMU
* 窗口会出现第一天指令的反汇编
`[f000:fff0] 0xffff0: ljmp $0xf000,$0xe05b`
* 是 GDB 对要执行的第一条指令的反汇编。从这个输出中，您可以得出一些结论：
* IBM PC 在物理地址 0x000ffff0 处开始执行，该地址位于为 ROM BIOS 保留的64KB 区域的最顶部。
* PC 以CS = 0xf000和IP = 0xfff0开始执行。
* 要执行的第一条指令是jmp指令，它跳转到分段地址 CS = 0xf000和IP = 0xe05b。

##### 练习2：使用 GDB 的si（Step Instruction）命令跟踪 ROM BIOS 以获取更多指令，并尝试猜测它可能在做什么。

* 代码如下
```C++
ljmp   $0xf000,$0xe05b      //跳转到0xfe05b
cmpl   $0x0,%cs:0x6ac8
jne    0xfd2e1              //jne指令：如果ZF标志位为0的时候跳转，即上一条指令cmpl的结果不是0时跳转，也就是$cs:0x6ac8地址处的值不是0x0时跳转。
xor    %dx,%dx              //把dx寄存器清零

mov    %dx,%ss              
mov    $0x7000,%esp
mov    $0xf34c2,%edx
jmp    0xfd15c
mov    %eax,%ecx

//关闭中断指令
cli    
//设置方向标识位为0，表示后续的串操作比如MOVS操作，内存地址的变化方向，如果为0代表从低地址值变为高地址。
cld    


mov    $0x8f,%eax
//IO端口，把$写入或者读到%中
//0x70端口和0x71端口是用于控制系统中一个叫做CMOS的设备，这个设备是一个低功耗的存储设备，它可以用于在计算机关闭时存储一些信息，它是由独立的电池供电的。
out    %al,$0x70
in     $0x71,%al            //可以认为这三条指令是用来关闭NMI中断的。


in     $0x92,%al            
or     $0x2,%al
out    %al,$0x92            //这三步操作又是在控制端口，此时被控制的端口号为0x92

lidtw  %cs:0x6ab8           //lidt指令：加载中断向量表寄存器(IDTR)。
lgdtw  %cs:0x6a74
mov    %cr0,%eax
or     $0x1,%eax
mov    %eax,%cr0
ljmpl  $0x8,$0xfd18f
mov    $0x10,%eax
mov    %eax,%ds
mov    %eax,%es
mov    %eax,%ss
mov    %eax,%fs
mov    %eax,%gs

```
* 总之，这个部分的操作就是把操作系统从磁盘中导入内存，然后再把控制权转交给操作系统

### PART2：引导加载程序
* 对于 6.828，我们将使用传统的硬盘驱动器引导机制，这意味着我们的引导加载程序必须适合 512 字节。引导加载程序包含一个汇编语言源文件boot/boot.S和一个 C 源文件boot/main.c 仔细查看这些源文件并确保您了解发生了什么。引导加载程序必须执行两个主要功能：

* 首先，引导加载程序将处理器从实模式切换到 32 位保护模式，因为只有在这种模式下，软件才能访问处理器物理地址空间中 1MB 以上的所有内存。保护模式在PC 汇编语言的1.2.7 和 1.2.8 节中进行了简要 介绍，在 Intel 架构手册中进行了详细介绍。在这一点上，您只需要了解分段地址（段：偏移量对）到物理地址的转换在保护模式下发生的不同，并且转换后偏移量是 32 位而不是 16 位。
* 其次，引导加载程序通过 x86 的特殊 I/O 指令直接访问 IDE 磁盘设备寄存器，从硬盘读取内核。如果您想更好地理解此处特定 I/O 指令的含义，请查看6.828 参考页上的“IDE 硬盘控制器”部分。在本课程中，您不需要学习太多关于特定设备编程的知识：编写设备驱动程序实际上是操作系统开发的一个非常重要的部分，但从概念或架构的角度来看，它也是最不有趣的部分。

* 了解引导加载程序源代码后，请查看文件obj/boot/boot.asm。这个文件是我们的 GNUmakefile在编译引导加载程序后创建的引导加载程序的反汇编。该反汇编文件可以轻松查看所有引导加载程序代码驻留在物理内存中的确切位置，并且可以更轻松地跟踪 GDB 中单步执行引导加载程序时发生的情况。同样，obj/kern/kernel.asm包含 JOS 内核的反汇编，这通常对调试很有用。

##### 练习3： 查看实验室工具指南，尤其是有关 GDB 命令的部分。即使您熟悉 GDB，这也包括一些对操作系统工作有用的深奥 GDB 命令。
>> https://pdos.csail.mit.edu/6.828/2018/labguide.html

#### 加载内核
* 详细查看boot/main.c中引导加载程序的c语言部分
##### 练习4：阅读有关在 C 中使用指针进行编程的内容。C 语言的最佳参考是 Brian Kernighan 和 Dennis Ritchie 的The C Programming Language（称为“K&R”）。我们建议学生购买这本书（这里是 亚马逊链接）或找到 麻省理工学院的 7本书中的 一 本。阅读 K&R 中的 5.1（指针和地址）到 5.5（字符指针和函数）。然后下载pointers.c的代码 ，运行它，并确保您了解所有打印值的来源。特别是，请确保您了解打印的第 1 行和第 6 行中的指针地址从何而来，打印的第 2 行到第 4 行中的所有值如何到达那里，以及为什么打印在第 5 行中的值似乎已损坏。

```C++
#include <stdio.h>
#include <stdlib.h>

void
f(void)
{
    int a[4];
    int *b = malloc(16);
    int *c;
    int i;

    printf("1: a = %p, b = %p, c = %p\n", a, b, c);

    c = a;
    for (i = 0; i < 4; i++)
	a[i] = 100 + i;
    c[0] = 200;
    printf("2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	   a[0], a[1], a[2], a[3]);

    c[1] = 300;
    *(c + 2) = 301;
    3[c] = 302;
    printf("3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	   a[0], a[1], a[2], a[3]);

    c = c + 1;
    *c = 400;
    printf("4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	   a[0], a[1], a[2], a[3]);

    c = (int *) ((char *) c + 1);
    //c先转为char*类型 + 1 再转为int* 类型步长不一样，所以在内存中，两段数据都会被修改
    *c = 500;
    printf("5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	   a[0], a[1], a[2], a[3]);

    b = (int *) a + 1;
    c = (int *) ((char *) a + 1);
    printf("6: a = %p, b = %p, c = %p\n", a, b, c);
}

int
main(int ac, char **av)
{
    f();
    return 0;
}
```

* 一个 ELF 二进制文件以一个固定长度的ELF 头开始，然后是一个 列出每个要加载的程序段的可变长度程序头。这些 ELF 头文件的 C 定义在inc/elf.h 中。我们感兴趣的程序部分是：

* .text：程序的可执行指令。
* .rodata：只读数据，例如 C 编译器生成的 ASCII 字符串常量。（不过，我们不会费心设置硬件来禁止写入。）
* .data : data 部分保存了程序的初始化数据，比如用int x = 5等初始化器声明的全局变量。

* 我们可以通过以下命令来查看内核中可执行文件中的名称大小和链接地址的完整列表：
```
objdump -h obj/kern/kernel
objdump -h obj/boot/boot.out
objdump -x obj/kern/kernel
```

##### 练习5：再次跟踪引导加载程序的前几条指令，并确定如果引导加载程序的链接地址错误，第一条指令会“中断”或以其他方式做错事。然后将boot/Makefrag 中的链接地址更改为 错误的内容，运行make clean，使用 重新编译实验室make，然后再次跟踪引导加载程序以查看会发生什么。之后不要忘记make clean一次又一次地更改链接地址！